<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Search & Sort</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
    integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="css/tutorials.css" />
  <link rel="shortcut icon" href="images/logo.jpg" type="image/x-icon" />
</head>

<body>
  </nav>
  <section class="hero">
    <a href="school.html" class="text-lg">Back</a>
    <div class="container">
      <div class="hero-content">
        <h1 class="hero-heading text-xl">Search & Sort</h1>
        <h2 class="text-lg">Sorting</h2>
        <div class="paragraph text-sm">
          <b>Sorting</b> is when you order an array in an ordered way, like ascending or descending.
          <br><br>
        </div>
      </div>
      <h3 class="text-md">Insertion Sort</h3>
      <div class="text-sm">
        <b>Insertion sort</b> is a sorting algorithm that iterates through the array. It compares every element before
        the current element to the current element. If the element is bigger, it gets shifted 1 index forward. If it is
        not greater, we place the current element at the index after. The time complexity is <b>O(n<sup>2</sup>)</b>.
        <br><br>
        <pre>
void sort(int arr[]) {
    int n = arr.length;
    for (int i = 1; i < n; ++i) {
        int key = arr[i];
        int j = i - 1;

        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}
        </pre>
        In the code, we are looping through each element of the array and storing it in the variable <b>key</b>. Then,
        we are comparing every element before <b>key</b> to <b>key</b>. The while loop stops until we find an element
        not greater than key, then we insert it in its correct position.
        <br><br>
      </div>
      <h3 class="text-md">Selection Sort</h3>
      <div class="text-sm">
        <b>Selection Sort</b> works by repeatedly selecting the smallest (or largest) element from the unsorted portion
        of a list and moving it to the sorted portion of the list. The time complexity is <b>O(n<sup>2</sup>)</b>
        <br><br>
        <pre>
public void sort(int arr[]) {
    int n = arr.length;

    for (int i = 0; i < n-1; i++) {
        int min_idx = i;
        for (int j = i+1; j < n; j++) {
            if (arr[j] < arr[min_idx]) {
                min_idx = j;
            }
        }
        int temp = arr[min_idx];
        arr[min_idx] = arr[i];
        arr[i] = temp;
    }
}
        </pre>
      </div>
      <h2 class="text-lg">Searching</h2>
      <div class="text-sm">
        <b>Searching</b> is when you search for a specified element in an array for when index it is at.
        <br><br>
      </div>
      <h3 class="text-md">Sequential Search</h3>
      <div class="text-sm">
        <b>Sequential Search</b> goes through an array one-by-one to find the specified element you are looking for. It
        compares the target value with each value of the array. It has a time complexity of <b>O(n)</b>.
        <br><br>
        <pre>
public static int Sequentialsearch(int arr[], int target) {
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == target) {
            return i;
        }
    }
    return -1;
}
        </pre>
      </div>
      <h3 class="text-md">Binary Search</h3>
      <div class="text-sm">
        <b>Binary Search</b> repeatedly divides in half the portion of the array that could contain the item, until the
        possible locations get narrowed down to just one. However, this searching algorithm only works if the array is
        sorted beforehand. It is faster than sequential search, with a time complexity of <b>O(log n)</b>.
        <br><br>
        <pre>
int binarySearch(int arr[], int x) {
    int l = 0, r = arr.length - 1;
    while (l <= r) {
        int m = l + (r - l) / 2;

        // Check if x is present at mid
        if (arr[m] == x) {
            return m;
        }

        // If x greater, ignore left half
        if (arr[m] < x) {
            l = m + 1;
        } 

        // If x is smaller, ignore right half
        else
            r = m - 1;
    }
    // If we reach here, then element was
    // not present
    return -1;
}
        </pre>
      </div>
      <h2 class="text-lg">Example</h2>
      <div class="text-sm">
        In this assignment, I had to sort students either by name or by grade. I used selection sort to sort the arrays.
        Since I had to make the name and grade correspond to each other, using selection sort allowed me to indentify
        the indices and swap the elements in the same indices in the parallel array.
        <br><br>
        <pre>
public void selectionSort(int arr[]) { //selection sort method to sort grades
  for(int i = 0; i < arr.length-1; i++) { 
      int min = i; 
      for(int j = i+1; j < arr.length; j++) {
        if(arr[j] > arr[min]) {
            min = j;
        }
      }
      int temp = arr[min];
      arr[min] = arr[i];
      arr[i] = temp;
      //swapping the names so the corresponding mark stays together
      String temp2 = names[min];
      names[min] =names[i];
      names[i] = temp2;
  }
}
        </pre>
      </div>
    </div>
  </section>
</body>

</html>