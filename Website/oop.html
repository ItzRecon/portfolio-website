<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>OOP</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
    integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="css/tutorials.css" />
  <link rel="shortcut icon" href="images/logo.jpg" type="image/x-icon" />
</head>

<body>
  </nav>
  <section class="hero">
    <a href="school.html" class="text-lg">Back</a>
    <div class="container">
      <div class="hero-content">
        <h1 class="hero-heading text-xl">Object Oriented Programming</h1>
        <h2 class="text-lg">Objects & Classes
        </h2>
        <div class="Objects & Classes text-sm">
          An Object Oriented Programming(OOP) language like Java organizes software design around objects, created from
          classes. A <b>class</b> is a user-defined template from which objects are created. It has attributes and
          methods. An object is a specific instance of a class.
          <br>
          <br>For example, a human has a set of attributes, like age, name, and height. However, to give these
          attributes values, we need to create an object. We can assign values to each attribute when creating an
          object.
          <br><br>
          Here is an example of a human class.
          <br>
          <br>
          <pre>
public class Human {
    private String name;
    private int age;
    private double height;
}
            </pre>
          <br>To create an object of the human class, we need a constructor. A <b>constructor</b> is a special type of
          method that is used to initialize objects.
          <br><br>
          <pre>
public class Human {
    private String name;
    private int age;
    private double height;

    public Human(String name, int age, double height) {
        this.name = name;
        this.age = age;
        this.height = height;
    }
}
            </pre>
          The <b>this</b> keyword specifies that I am referring to the variable in this class, since I have 2 variables
          with the same name.
          <br>
          <br>
          When creating an object, it usually happens in a seperate driver class, in the main method. You use the
          <b>new()</b> keyword to create an object, and the constructor of the object is called in the parentheses. Keep
          in mind that the driver class has to be in the same folder as the class you are creating an object of.
          <br><br>
          <pre>
public class Driver{
    public static void main(String[] args) {
        Human bob = new Human("Bob", 14, 140.5);
    }
}
            </pre>
          In the code, a new instance of the Human class is being assigned to a variable of type Human. Classes are
          basically data types.
          <br><br>
          In addition to attributes, classes can also have methods that access/change the attributes. Since the
          attributes in our human class are <b>private</b>, it can only be accessed within the declared class. If it
          were <b>public</b>, it would be able to be accessed by any other class. These are called <b>access
            modifiers</b>. There are many different access modifiers. Here is a table to help you understand them.
          <br><br>
          <img src="/images/access modifiers.jpg" alt="Access Modifiers">
          <br><br>
          Since our attributes are private, we need what we call <b>get methods</b> to retrieve those attributes. Method
          that change those attributes are called <b>set methods</b>. Let's add methods to our Human class.
          <br><br>
          <pre>
public class Human {
    private String name;
    private int age;
    private double height;

    public Human(String name, int age, double height) {
        this.name = name;
        this.age = age;
        this.height = height;
    }

    public void addAge() { //set method
        age++;
    }

    public void addHeight(double h) { //set method
        height += h;
    }

    public String getName() { //get method
        return name;
    }

    public int getAge() { //get method
        return age;
    }

    public double getHeight() { //get method
        return height;
    }
}
            </pre>
          Now let's see if our methods work.
          <br><br>
          <pre>
public class Driver{
    public static void main(String[] args) {
        Human bob = new Human("Bob", 14, 140.5);
        System.out.println(bob.getName()); //outputs Bob
        System.out.println(bob.getAge()); //outputs 14
        System.out.println(bob.getHeight()); //outputs 140.5
        bob.addAge(); //adds 1 to age
        bob.addHeight(1.5); //adds 1.5 to height
        System.out.println(bob.getName()); //outputs Bob (we haven't done anything to name)
        System.out.println(bob.getAge()); //outputs 15 (addAge() added 1 to age)
        System.out.println(bob.getHeight()); //outputs 142.0 (we added 1.5 to height using addHeight)
    }
}       
        </pre>
          It's important to note that if you have 2 objects of the same class, you have 2 instances of that class. So,
          what you do to one object will not happen to the other.
        </div>
        <h2 class="text-lg">Inheritance</h2>
        <div class="inheritance text-sm">
          In Java, you can inherit attributes and methods from one class to another. We can group inheritance into 2
          categories:
          <br><br>
          <b>Subclass</b>(child): The class that inherits from another class.
          <br><b>Superclass</b>(parent): The class being inherited from.
          <br><br>
          To inherit a from a class, we use the <b>extends</b> keyword. Let's see an example.
          <br><br>
          <pre>
//Superclass
public class Animal {
    private String name;

    public Animal(String name) {
        this.name = name;
    }

    public void makeSound() {
        System.out.println("Animal makes a sound");
    }

    public String getName() { //returns name of Animal
        return name;
    }
}

//Subclass
public class Dog extends Animal {
    public Dog(String name) {
        super(name); // Call the superclass constructor
    }
}

public class Main {
    public static void main(String[] args) {
        // Create an instance of the Dog class
        Dog myDog = new Dog("Buddy");

        System.out.println(getName()); //outputs Buddy
        System.out.println(myDog.makeSound()); //outputs Animal makes a sound
    }
}
            </pre>
          In the above example, you can see that the subclass Dog still runs the method makeSound() from the Animal
          class, even though there is no such method in the Dog class. This is because Dog inherits the attributes and
          methods from the Animal class.
          <br><br>
          You may have noticed the usage of the keyword super. The <b>super</b> keyword allows referencing the
          superclass of a subclass in Java. This makes the program more simple because we do not have to create a new
          attribute for Dog.
          <br><br>
          One thing to note is that a subclass can only extend 1 class. Also, a subclass does not inherit any private
          methods/attributes from the superclass.
          <br><br>
          Inheritance is very useful in Java because it allows programmers to create new classes based on existing
          classes, enabling code reusability and organisation.
        </div>
        <h2 class="text-lg">Polymorphism</h2>
        <div class="polymorphism text-sm">
          <b>Polymorphism</b> means "many forms". In Java, this often means that a subclass can be treated as a
          superclass. Let's use our example from above.
          <br><br>
          <pre>
//Superclass
public class Animal {
    private String name;

    public Animal(String name) {
        this.name = name;
    }

    public void makeSound() {
        System.out.println("Animal makes a sound");
    }

    public String getName() { //returns name of Animal
        return name;
    }
}

//Subclass
public class Dog extends Animal {
    public Dog(String name) {
        super(name); // Call the superclass constructor
    }

    @Override
    public void makeSound() { //new method that overrides method in animal class
        System.out.println("Woof");
    }
}

public class Main {
    public static void main(String[] args) {
        // Create an instance of the Dog class assigned to a variable of type Animal
        Animal myDog = new Dog("Buddy");
        System.out.println(myDog.makeSound()); //outputs Woof
    }
}   
            </pre>
          In the example above, we can see that the Dog object can be treated of type Animal, since it is a subclass of
          Animal. Because the object is a Dog object, Java excecutes the overriden version of makeSound() in Dog instead
          of the one in Animal.
          <br><br>
          It is important to note that Java will only excecute the method in the subclass if it is overriding a method
          in the superclass. If there is no such method being overriden in the superclass, there will be an error.
          However, if there is no such method in the subclass but the method is in the superclass, Java will call the
          method in the superclass.
        </div>
        <h2 class="text-lg">Abstract Classes</h2>
        <div class="abstract text-sm">
          <b>Abstraction</b> is the process of hiding certain details and showing only functionality to the user.
          <br><br>
          An <b>abstract class</b> is a restricted class that cannot be used to create objects (to access it, it must be
          inherited by another class).
          An <b>abstract method</b> can only be used in an abstract class, and it does not have a body. The body is
          provided by the subclass.
          <br><br>
          To make an abstract class, we must use the <b>abstract</b> keyword.
          <br><br>
          An abstract class can have both abstract methods and normal methods. When extending an abstract class, all the
          abstract methods must be overriden.
          <br><br>
          <pre>
public abstract class Animal {
  public abstract void animalSound();
  public void sleep() {
    System.out.println("zzz");
  }
}
            </pre>
          Abstract classes are useful because it provides a base for the subclasses to use. It lets each subclass
          customize the method according to its needs.
        </div>
        <h2 class="text-lg">Interfaces</h2>
        <div class="interfaces text-sm">
          An <b>interface</b> is a class that is used to group related methods with empty bodies.
          <br><br>
          Unlike abstract classes, it cannot contain normal methods. Like abstract classes, it cannot be used to create
          objects.
          <br><br>
          <pre>
public interface Animal {
  public void animalSound(); // interface method (does not have a body)
  public void sleep(); // interface method (does not have a body)
}
            </pre>
          To access interface methods, the interface must be implemented, using the <b>implements</b> keyword. The body
          of the interface methods are provided by the class that implements the interface.
          <br><br>
          <pre>
public class Pig implements Animal {
  public void animalSound() {
    // The body of animalSound() is provided here
    System.out.println("The pig says: oink");
  }
  public void sleep() {
    // The body of sleep() is provided here
    System.out.println("Zzz");
  }
}
            </pre>
          When you implement an interface, you must override all of its methods.
          <br><br>
          Interfaces are useful because they don't require you to worry about the implementation of the method. It also
          allows you to hide details of the classes that implement the interface, only showing the essential
          functionality.
        </div>
        <h2 class="text-lg">Example</h2>
        <div class="example text-sm">
          Now, let's take a look at an example of a project I used OOP in.
          <br><br>
          In this project, I was with Harry and our assignment was to upgrade a fantasy game by adding locations and
          characters using OOP. I used interfaces and polymorphism for this project.
          <br><br>
          Using an interface for the characters made it easier to organize, since all the characters had the same
          methods to implement.
          <br><br>
          <pre>
interface Character {
   String getName();
   int takeGold(int available);
   void drinkPotion();
   void exposeToRadiation();
}
            </pre>
          I used polymorphism when I assigned different characters into 1 room, using an ArrayList of type Character.
          Since all the characters implement the Character interface, I can store all my character objects into 1 array.
          This makes the code much easier since if I didn't have an interface, I would have to create an ArrayList to
          store each type of character.
          <br><br>
          <pre>
import java.util.ArrayList;
class DarkRoom {
   String name;
   int gold;
   boolean radioactive;
	
   ArrayList<Character> elves; //arraylist to store the characters that are currently in the room

   DarkRoom(String name, int gold, boolean radioactive)
   {
      this.name = name;
      this.gold = gold;
      this.radioactive = radioactive;
   	
      elves = new ArrayList<Character>();
   }
	
   void enter(Character elf)
   {
      elves.add(elf); //adding a character
      
      if (radioactive)
         elf.exposeToRadiation();
   	
      gold = elf.takeGold(gold);
   }
	
   void exit(Character elf)
   {
      elves.remove(elf);
   }

   String getName() {
   	
      return name;
   }
}
            </pre>
        </div>
      </div>
    </div>
  </section>
</body>

</html>